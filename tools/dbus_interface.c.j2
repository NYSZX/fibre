#ifndef __INTERFACES__{{output_name | replace('.', '_') | upper}}
#define __INTERFACES__{{output_name | replace('.', '_') | upper}}

#include <fibre/dbus.hpp>
#include <fibre/closure.hpp>
#include <vector>

{%- macro args_to_types(args) %}
{%- for arg in args %}
{{- arg.type | dbus_type_to_cpp_type}}{% if not loop.last %}, {% endif %}
{%- endfor %}
{%- endmacro %}

{%- macro args_to_names(args) %}
{%- for arg in args %}{{arg.name}}{% if not loop.last %}, {% endif %}{% endfor %}
{%- endmacro %}

{%- macro arg_list(args, type, name, prefix, delimiter, suffix) %}
{%- for arg in args %}
{{- prefix}}
{%- if type %}{{arg.type | dbus_type_to_cpp_type}}{% endif %}
{%- if name and type %} {% endif %}
{%- if name %}{{arg.name}}{% endif %}
{%- if not loop.last %}{{delimiter}}{% endif %}
{{- suffix}}
{%- endfor %}
{%- endmacro %}

{%- macro arg_list_t(args) %}{{arg_list(args, true, false, "", ", ", "")}}{%- endmacro %}
{%- macro arg_list_n(args) %}{{arg_list(args, false, true, "", ", ", "")}}{%- endmacro %}
{%- macro arg_list_ct(args) %}{{arg_list(args, true, false, ", ", "", "")}}{%- endmacro %}
{%- macro arg_list_cn(args) %}{{arg_list(args, false, true, ", ", "", "")}}{%- endmacro %}
{%- macro arg_list_tc(args) %}{{arg_list(args, true, false, "", "", ", ")}}{%- endmacro %}
{%- macro arg_list_tnc(args) %}{{arg_list(args, true, true, "", "", ", ")}}{%- endmacro %}
{%- macro arg_list_ctn(args) %}{{arg_list(args, true, true, ", ", "", "")}}{%- endmacro %}

{%- for interface in all_interfaces %}
{% set interface_name = interface.name | replace('.', '_') %}
class {{interface_name}} {
public:
    static const char* get_interface_name() { return "{{interface.name}}"; }

    {{interface_name}}(fibre::DBusRemoteObjectBase* base)
        : base_(base) {}
    
    // For now we delete the copy constructor as we would need to change the references within the signal objects for copying an object properly
    {{interface_name}}(const {{interface_name}} &) = delete;
    {{interface_name}}& operator=(const {{interface_name}} &) = delete;

{% for method in interface.methods %}
    int {{method.name}}_async({{arg_list_tnc(method.inputs)}}fibre::Callback<{{interface_name}}*{{arg_list_ct(method.outputs)}}>* callback) {
        return base_->method_call_async(this, "{{method.name}}", callback{{arg_list_cn(method.inputs)}});
    }
{% endfor %}

{%- for property in interface.properties %}
    // DBusProperty<{{property.type | dbus_type_to_cpp_type}}> {{property.name}};
{%- endfor %}

{%- for signal in interface.signals %}
    fibre::DBusRemoteSignal<{{interface_name}}{{arg_list_ct(signal.args)}}> {{signal.name}}{this, "{{signal.name}}"};
{%- endfor %}

    struct ExportTable : fibre::ExportTableBase {
        ExportTable() : fibre::ExportTableBase{
{%- for method in interface.methods %}
            { "{{method.name}}", fibre::FunctionImplTable{} },
{%- endfor %}
        } {}
        std::unordered_map<fibre::dbus_type_id_t, size_t> ref_count{}; // keeps track of how often a given type has been registered

        template<typename ... TArgs>
        using signal_closure_t = fibre::Closure<void(fibre::DBusConnectionWrapper::*)(std::string, fibre::DBusObjectPath, TArgs...), std::tuple<fibre::DBusConnectionWrapper*, std::string, fibre::DBusObjectPath>, std::tuple<TArgs...>, void>;

        template<typename ... TArgs>
        using signal_table_entry_t = std::pair<signal_closure_t<TArgs...>, void(*)(void*, signal_closure_t<TArgs...>&)>;

{%- for signal in interface.signals %}
        std::unordered_map<std::string, signal_table_entry_t<{{arg_list_t(signal.args)}}>> {{signal.name}}_callbacks{};
{%- endfor %}

        template<typename TImpl>
        void register_implementation(fibre::DBusConnectionWrapper& conn, fibre::DBusObjectPath path, TImpl& obj) {
            if (ref_count[fibre::get_type_id<TImpl>()]++ == 0) {
{%- for method in interface.methods %}
                (*this)["{{method.name}}"].insert({fibre::get_type_id<TImpl>(), [](void* obj, DBusMessage* rx_msg, DBusMessage* tx_msg){ return fibre::DBusConnectionWrapper::handle_method_call_typed(rx_msg, tx_msg, fibre::make_tuple_closure(&TImpl::{{method.name}}, (TImpl*)obj, (std::tuple<{{arg_list_t(method.outputs)}}>*)nullptr)); {{'}})'}};
{%- endfor %}
            }
{%- for signal in interface.signals %}
            obj.{{signal.name}} += &({{signal.name}}_callbacks.insert({path + " @ " + conn.get_name(), {fibre::make_closure(&fibre::DBusConnectionWrapper::emit_signal<{{interface_name}}{{arg_list_ct(signal.args)}}>, &conn).bind(std::string("{{signal.name}}")).bind(path), [](void* ctx, signal_closure_t<{{arg_list_t(signal.args)}}>& cb){ ((TImpl*)ctx)->{{signal.name}} -= &cb; } } }).first->second.first);
{%- endfor %}
        }

        int deregister_implementation(fibre::DBusConnectionWrapper& conn, fibre::DBusObjectPath path, void* obj, fibre::dbus_type_id_t type_id) {
{%- for signal in interface.signals %}
            {
                auto it = {{signal.name}}_callbacks.find(path + " @ " + conn.get_name());
                it->second.second(obj, it->second.first);
                {{signal.name}}_callbacks.erase(it);
            }
{%- endfor %}
            auto it = ref_count.find(type_id);
            if (it == ref_count.end()) {
                return -1;
            }
            if (--(it->second) == 0) {
{%- for method in interface.methods %}
                (*this)["{{method.name}}"].erase((*this)["{{method.name}}"].find(type_id));
{%- endfor %}
                ref_count.erase(it);
            }
            return 0;
        }
    };

    fibre::DBusRemoteObjectBase* base_;
};


{%- endfor %}

#endif // __INTERFACES__{{output_name | replace('.', '_') | upper}}