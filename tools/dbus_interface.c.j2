#ifndef __INTERFACES__{{output_name | replace('.', '_') | upper}}
#define __INTERFACES__{{output_name | replace('.', '_') | upper}}

#include <fibre/dbus.hpp>
#include <fibre/callback.hpp>
#include <vector>

{%- macro args_to_types(args) %}
{%- for arg in args %}
{{- arg.type | dbus_type_to_cpp_type}}{% if not loop.last %}, {% endif %}
{%- endfor %}
{%- endmacro %}

{%- macro args_to_names(args) %}
{%- for arg in args %}{{arg.name}}{% if not loop.last %}, {% endif %}{% endfor %}
{%- endmacro %}

{%- macro arg_list(args, type, name, prefix, delimiter, suffix) %}
{%- for arg in args %}
{{- prefix}}
{%- if type %}{{arg.type | dbus_type_to_cpp_type}}{% endif %}
{%- if name and type %} {% endif %}
{%- if name %}{{arg.name}}{% endif %}
{%- if not loop.last %}{{delimiter}}{% endif %}
{{- suffix}}
{%- endfor %}
{%- endmacro %}

{%- macro arg_list_t(args) %}{{arg_list(args, true, false, "", ", ", "")}}{%- endmacro %}
{%- macro arg_list_n(args) %}{{arg_list(args, false, true, "", ", ", "")}}{%- endmacro %}
{%- macro arg_list_ct(args) %}{{arg_list(args, true, false, ", ", "", "")}}{%- endmacro %}
{%- macro arg_list_cn(args) %}{{arg_list(args, false, true, ", ", "", "")}}{%- endmacro %}
{%- macro arg_list_tc(args) %}{{arg_list(args, true, false, "", "", ", ")}}{%- endmacro %}
{%- macro arg_list_tnc(args) %}{{arg_list(args, true, true, "", "", ", ")}}{%- endmacro %}
{%- macro arg_list_ctn(args) %}{{arg_list(args, true, true, ", ", "", "")}}{%- endmacro %}

{%- for interface in all_interfaces %}
{% set interface_name = interface.name | replace('.', '_') %}
class {{interface_name}} : public fibre::DBusObject {
public:
    static const char* get_interface_name() { return "{{interface.name}}"; }

    {{interface_name}}(fibre::DBusConnectionWrapper* conn, const char* service_name, const char* object_name)
        : DBusObject(conn, service_name, object_name) {}
    
    // For now we delete the copy constructor as we would need to change the references within the signal objects for copying an object properly
    {{interface_name}}(const {{interface_name}} &) = delete;
    {{interface_name}}& operator=(const {{interface_name}} &) = delete;

{% for method in interface.methods %}
    int {{method.name}}_async({{arg_list_tnc(method.inputs)}}fibre::Callback<{{arg_list_t(method.outputs)}}>* callback) {
        return method_call_async(get_interface_name(), "{{method.name}}", callback{{arg_list_cn(method.inputs)}});
    }
{% endfor %}

{%- for property in interface.properties %}
    // DBusProperty<{{property.type | dbus_type_to_cpp_type}}> {{property.name}};
{%- endfor %}

{%- for signal in interface.signals %}
    fibre::DBusRemoteSignal<{{interface_name}}{{arg_list_ct(signal.args)}}> {{signal.name}}{this, "{{signal.name}}"};
{%- endfor %}

    struct ExportTable : fibre::ExportTableBase {
        ExportTable() : fibre::ExportTableBase{
{%- for method in interface.methods %}
            { "{{method.name}}", fibre::FunctionImplTable{} },
{%- endfor %}
        } {}

        template<typename TImpl>
        int register_implementation(TImpl& obj) {
{%- for method in interface.methods %}
            (*this)["{{method.name}}"].insert({fibre::get_type_id<TImpl>(), [](void* obj, DBusMessage* rx_msg, DBusMessage* tx_msg){ return fibre::DBusConnectionWrapper::handle_method_call_typed(rx_msg, tx_msg, fibre::make_tuple_closure(&TImpl::{{method.name}}, (TImpl*)obj, (std::tuple<{{arg_list_t(method.outputs)}}>*)nullptr)); {{'}})'}};
{%- endfor %}
            return 0;
        }
    };
};


{%- endfor %}

#endif // __INTERFACES__{{output_name | replace('.', '_') | upper}}